---
import BaseLayout from "../layouts/BaseLayout.astro";
import { client, urlFor } from "../lib/sanity";


// Fetch work documents with thumbnails and category (array)
const works = await client.fetch(`*[_type == "work"]{
  category,
  thumbnail[]{
    _type,
    asset,
    "videoUrl": asset->url,
    "fileType": asset->mimeType,
    poster,
  }
}`);

// Group thumbnail URLs by category
const categoryImages = { identity: [], website: [], book: [], other: [] };

for (const work of works) {
  const categories = Array.isArray(work.category) ? work.category : [work.category || 'other'];
  for (const cat of categories) {
    if (!categoryImages[cat]) categoryImages[cat] = [];
    if (work.thumbnail) {
      for (const thumb of work.thumbnail) {
        if (thumb._type === 'image' && thumb.asset) {
          // Use urlFor to get a 600px wide thumbnail
          categoryImages[cat].push({ type: 'image', url: urlFor(thumb.asset).width(1200).url() });
        }
        if (thumb._type === 'video' && thumb.videoUrl) {
          // Prefer poster image if available, else use video URL
          let posterUrl = undefined;
          if (thumb.poster && thumb.poster.asset) {
            posterUrl = urlFor(thumb.poster.asset).width(600).url();
          }
          categoryImages[cat].push({ type: 'video', url: thumb.videoUrl, poster: posterUrl });
        }
      }
    }
  }
}

---
<BaseLayout title="Matthew Bradley">
<section class="hero" id="hero-stack">
  <div class="hero-inner">
    <h1>
      <div class="link-container">
        <a href="/identities">Identities</a>
        <div class="link-images" data-images={JSON.stringify(categoryImages.identity)}></div>
      </div>, 
      <div class="link-container">
        <a href="/websites">Websites</a>
        <div class="link-images" data-images={JSON.stringify(categoryImages.website)}></div>
      </div>, 
      <div class="link-container">
     
        <div class="link-images" data-images={JSON.stringify(categoryImages.book)}></div>
           <a href="/books">Books</a>
      </div>,
      <div class="link-container">
        <a href="/works">and other graphic solutions.</a>
        <div class="link-images" data-images={JSON.stringify(categoryImages.other)}></div>
      </div>
    </h1>
  </div>
  <script>
      const heroStack = document.getElementById('hero-stack');
      // Preload and cache media elements
      const mediaCache = {};
      document.querySelectorAll('.link-container').forEach(container => {
        const link = container.querySelector('a');
        const imagesDiv = container.querySelector('.link-images');
        const images = JSON.parse(imagesDiv.getAttribute('data-images'));
        // Preload first image/video for each link
        if (images.length) {
          const preloadItem = images[0];
          if (preloadItem.type === 'image') {
            const img = new Image();
            img.src = preloadItem.url;
            mediaCache[preloadItem.url] = img;
          } else if (preloadItem.type === 'video') {
            const vid = document.createElement('video');
            vid.src = preloadItem.url;
            vid.preload = 'auto';
            if (preloadItem.poster) vid.poster = preloadItem.poster;
            mediaCache[preloadItem.url] = vid;
          }
        }
        let mediaElem = null;
        let lastUrl = null;
        link.addEventListener('mouseenter', () => {
          if (!images.length) return;
          // Filter out last shown image
          let filteredImages = images;
          if (lastUrl && images.length > 1) {
            filteredImages = images.filter(img => img.url !== lastUrl);
          }
          const randomItem = filteredImages[Math.floor(Math.random() * filteredImages.length)];
          lastUrl = randomItem.url;
          // Random position within heroStack
          const rect = heroStack.getBoundingClientRect();
          const left = Math.random() * (rect.width - 600);
          const top = Math.random() * (rect.height - 600);
          // Use cached/preloaded element if available
          if (mediaCache[randomItem.url]) {
            mediaElem = mediaCache[randomItem.url].cloneNode(true);
          } else {
            if (randomItem.type === 'image') {
              mediaElem = document.createElement('img');
              mediaElem.src = randomItem.url;
              mediaCache[randomItem.url] = mediaElem;
            } else if (randomItem.type === 'video') {
              mediaElem = document.createElement('video');
              mediaElem.src = randomItem.url;
              mediaElem.autoplay = true;
              mediaElem.muted = true;
              mediaElem.loop = true;
              mediaElem.playsInline = true;
              if (randomItem.poster) {
                mediaElem.poster = randomItem.poster;
              }
              mediaElem.preload = 'auto';
              mediaCache[randomItem.url] = mediaElem;
            }
          }
          if (mediaElem) {
            mediaElem.style.position = 'absolute';
            mediaElem.style.zIndex = '1';
            mediaElem.style.pointerEvents = 'none';
            mediaElem.style.maxWidth = '600px';
            mediaElem.style.maxHeight = '600px';
            mediaElem.style.transition = 'opacity 0.2s';
            mediaElem.style.opacity = '1';
            mediaElem.style.left = `${left}px`;
            mediaElem.style.top = `${top}px`;
            heroStack.appendChild(mediaElem);
          }
        });
        link.addEventListener('mouseleave', () => {
          if (mediaElem) {
            mediaElem.style.opacity = '0';
            setTimeout(() => {
              if (mediaElem && mediaElem.parentNode) {
                mediaElem.parentNode.removeChild(mediaElem);
                mediaElem = null;
              }
            }, 200);
          }
        });
      });
  </script>
</section>
</BaseLayout>